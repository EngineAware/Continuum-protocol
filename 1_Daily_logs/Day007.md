# Daily Learning Log — Rust  
**Date:** 2025-11-18  
**Book:** *Hands-On Rust* — Herbert Wolverson  
**Section:** Variables, Mutability, and `&str`
**Time Spent:** ~1 hour
---

## 1. Subject
Rust Programming — Core Fundamentals

---

## 2. Topics Covered
- Creating a new Rust project with `cargo new`
- Understanding project folders (`src`, `Cargo.toml`, `target/debug`)
- What build artifacts are
- What `.d` files are
- Difference between running the binary vs. using `cargo run`
- Rust project structure (`cargo new`)
- Running programs (`cargo run`), building (`cargo build`)
- Debug vs Release builds
- Variables (`let`)
- Mutability (`let mut`)
- Basic data types: `i32`, `f64`, `bool`, `char`, `&str`
- Deep explanation of `&str` (string slice)
- Difference between `&str` and `String`
- String ownership and borrowing
- Converting `&str` to `String`
- Using `println!` formatting

---

## 3. Exercises Completed
- Created a new Rust project
- Wrote a "Hello, world" program
- Practiced declaring and modifying variables
- Printed multiple data types
- Triggered and inspected immutability errors
- Worked with `&str` references
- Converted `&str` → `String` and appended text

---

## 4. Key Concepts Learned
### Cargo
Rust’s build system for creating, compiling, and managing projects
### Variables & Mutability
- `let` creates immutable variables by default  
- `let mut` enables changes to values

### Data Types
- Rust infers types, but explicit typing is allowed  
- Strong typing enforces safety and avoids type errors

### `&str` — String Slice
- A borrowed reference to text stored elsewhere  
- Fast, lightweight, read-only  
- Ideal for hardcoded text or when no mutation is needed

### `String`
- Heap-allocated, owned, growable  
- Necessary when modifying or constructing text dynamically

### Ownership & Borrowing
- `&str` borrows; `String` owns  
- Convert using:
  ```rust
  let s = String::from("Hello)
- 

### target/debug Folder
Stores:
- Compiled executable

# Daily Log – Computer Science  
**Book:** *Code: The Hidden Language of Computer Hardware and Software* – Charles Petzold   
**Current Page:** 6  
**Time Spent:** ~1 hour

---

## Subject  
Fundamentals of Communication (Page 6)

---

## Topics Covered
- Communication without spoken language  
- Signals and shared codes  
- Sender → Channel → Receiver model  
- Encoding and decoding principles  
- Simple communication systems using light/claps  
- Foundation for understanding binary and digital communication  

---

## Key Concepts Learned
- Any communication system needs:
  - A signal (light, sound, voltage)  
  - A shared code (agreed rules)  

- Every communication process follows:
  1. Sender  
  2. Message  
  3. Encoding  
  4. Channel  
  5. Receiver  
  6. Decoding  

- Computers use electrical signals encoded as binary (1/0).  
- Codes must be **unambiguous**; the receiver must know where each letter ends.  
- Fixed-length patterns (e.g., 5-bit codes) remove ambiguity and allow consistent decoding.

---

## Problems Solved
1. Converted **C A B** into **6 claps** using coded rules.  
2. Identified Sender, Channel, Receiver for a WhatsApp message.  
3. Designed a basic ON/OFF alphabet signaling system.

---

## Challenge Outcome
- Proposed numeric patterns for alphabet encoding.  
- Understood the importance of fixed-length codes to avoid confusion.

---

## Progress
- Completed **Page 6**  
- Built foundation for binary encoding, logic systems, and later CPU/memory concepts.
